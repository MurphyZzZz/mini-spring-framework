<html xmlns="http://www.w3.org/1999/html">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>
<body>
<p class="example">
    Mini-Spring-Framework是一款轻量级依赖注入框架，能够自动创建、管理和销毁实例并限制其生命周期。<br/>
    在介绍具体用法之前，有几个概念需要理解：<br/>
    1. Bean - 被容器管理的对象就叫做Bean<br/>
    2. Container - ApplicationContext 接口代表一个container。 容器负责实例化、配置和组装称为 bean 的对象，以及管理它们的生命周期。<br/>
    <br/>
    使用说明：<br/>
    <br/>
    - 阶段1
    <br/>
    1. 构造函数注入
    容器将调用带有参数的构造函数，每个参数代表我们要设置的依赖项。同时，需要把交给容器管理的Bean加入到容器中。
<pre><code class="language-java">
public interface Peelable {
  void peel();
}
public class Apple implements Peelable {
  public void peel() { }
}
public class Peeler implements Startable {
  private final Peelable peelable;
  public Peeler(Peelable peelable) {
    this.peelable = peelable;
  }
  public void start() {
	peelable.peel();
  }
  public void stop() { }
}
public class Juicer {
  private final Peelable peelable;
  private final Peeler peeler;
  public Juicer(Peelable peelable, Peeler peeler) {
    this.peelable = peelable;
    this.peeler = peeler;
  }
}
</code></pre>


2. 组装Bean到Container中
<pre><code class="language-java">
MutablePicoContainer pico = new DefaultPicoContainer();
pico.addComponent(Apple.class);
pico.addComponent(Juicer.class);
pico.addComponent(Peeler.class);
</code></pre>



3. 实例化组件
从容器中取出实例化的组件。
<pre><code class="language-java">
Juicer juicer = (Juicer) pico.getComponent(Juicer.class);
</code></pre>

- 阶段2<br/>

    1. 定义一个可管理的Bean。<br/>
    使用
    <span class="variable" data-name="managed-bean">@Controller/@Service/@Repository/@Component/@Bean</span>
    来标示这是一个可被容器管理的Bean。<br/>
<pre><code class="language-java">
@Configuration
public class AppConfig {

    @Bean
    public Item item1() {
        return new ItemImpl1();
    }

    @Bean
    public Store store() {
        return new Store(item1());
    }
}
</code></pre>
这里我们使用注解来通知 Spring 运行时这个类提供了 bean 定义（@Bean 注解），并且需要为额外的 bean 执行上下文扫描。 接下来，我们定义一个 Car 类：
<pre><code class="language-java">
@Component
public class Car {

    @Autowired
    public Car(Engine engine, Transmission transmission) {
        this.engine = engine;
        this.transmission = transmission;
    }
}
</code></pre>
Spring 将在执行包扫描时遇到我们的 Car 类，并将通过调用 @Autowired 带注释的构造函数来初始化其实例。

通过调用Config类的@Bean注解方法，我们将获得Engine和Transmission的实例。 最后，我们需要使用我们的 POJO 配置来引导一个 ApplicationContext：
<pre><code class="language-java">
ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
Car car = context.getBean(Car.class);
</code></pre>
    <br/>

    3. Bean的周期事件。<br/>
    <span class="variable" data-name="lifecycle-event">@PostConstruct</span>
    标记的方法会被执行，当Bean需要的所有依赖注入完成后。<br/>
    <span class="variable" data-name="lifecycle-event">@PreDestroy</span>
    标记的方法会被执行，当这个Bean的Scope被回收后。<br/>
    <br/>
    4. Bean的生命周期。<br/>
    提供以下生命周期：Prototype、Request、Session、Singleton（默认）<br/>
    <span class="variable" data-name="bean-scope">@Scope</span>
    可用来设置一个Bean的生命周期。<br/>
    不同生命周期的两个Beans，也允许注入。比如：AClass的生命周期是Singleton，需要注入BClass，但是BClass的生命周期是Request。<br/>
    <br/>
    5. 可替换的Bean注入。<br/>
    <span class="variable" data-name="alternative">@Primary</span>
    注解标记这是Bean注入的备选方。<br/>
    比如：
    当我们有ServiceAClass和ServiceBClass同时实现了ServiceClass这个接口，RestaurantClass需要注入一个ServiceClass的时候，当
    我们在ServiceAClass上加上@Primary的时候，这个时候Container会把ServiceBClass注入到RestaurantClass中。<br/>
    <br/>
    6.自定义Bean的创建。<br/>
    当Container创建一个Bean的时候，默认情况下，会使用Object中不带参数的构造函数。所以，如果想要使用带有参数的构造函数，
    可以使用
    <span class="variable" data-name="custom-bean">@Configuration</span>
    和
    <span class="variable" data-name="custom-bean">@Bean</span>。<br/>
    注意：使用@Bean时，需要使用@Scope来指定其生命周期。<br/>

</p>
</body>
</html>
